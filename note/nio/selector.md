## Selector

选择器提供选择执行已经就绪的任务的能力，这使得多元 I/O 成为可能，就绪选择和多元执行使得单线程能够有效率地同时管理多个 I/O 通道，C/C++ 代码的工具箱中，许多年前就已经有 _select()_ 和 _poll()_ 这两个 POSIX ( 可移植性操作系统接口 ) 系统调用可供使用了

### 1. 选择器基础

从最基础的层面来看，选择器提供了询问通道是否已经准备好执行每个 I/O 操作的能力，例如，我们需要了解一个 SocketChannel 对象是否还有更多的字节需要读取，或者我们需要知道 ServerSocketChannel 是否有需要准备接受的连接

在与 SelectableChannel 联合使用时，选择器提供了这种服务，就绪选择的真正价值在于潜在的大量的通道可以同时进行就绪状态的检查，调用者可以轻松地决定多个通道中的哪一个准备好要运行，有两种方式可以选择：

- 线程处于休眠状态，直到至少一个注册到选择器的通道就绪
- 也可以周期性地轮询选择器，看看从上次检查之后，是否有通道处于就绪状态

传统的监控多个 socket 的 Java 解决方案是为每个 socket 创建一个线程并使得线程可以在 _read()_ 调用中阻塞，直到数据可用，这事实上将每个被阻塞的线程当作了 socket 监控器，并将 Java 虚拟机的线程调度当作了通知机制，这两种本来都不是为了这种目的而设计的，程序员和 Java 虚拟机都为管理所有这些线程的复杂性和性能损耗付出了代价，这在线程数量的增长失控时表现得更为突出

真正的就绪选择必须由操作系统来做，操作系统的一项最重要的功能就是处理 I/O 请求并通知各个线程它们的数据已经准备好了，选择器类提供了这种抽象，使得 Java 代码能够以可移植的方式，请求底层的操作系统提供就绪选择服务

```tex
                         用户空间               内核空间             外部设备
                           进程                 操作系统           网卡、磁盘等
                   ↙ SelectableChannel1            ↑
    Selector   ← ← ← SelectableChannel2            |
       ↓           ↖ SelectableChanneln            |
       |									    |
       |	       select / poll / epoll		  |
       | ————————————————————————————————————————> |
```

